/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta_util>
#include <hamsandwich>
#include <xs>
#include <td>
#include <colorchat>
#include <cvar_util>

#pragma dynamic 32768 

#define PLUGIN "TD Turrets: New"
#define VERSION "0.4"
#define AUTHOR "GT Team"

#define MAX_PLAYER_TURRET 3
#define MAX_SERVER_TURRET 20

#define EV_INT_turret_id 	EV_INT_iuser1
#define EV_INT_turret_type 	EV_INT_iuser2
#define EV_INT_turret_firemode 	EV_INT_iuser3
#define EV_INT_turret_target	EV_INT_iuser4
#define EV_ENT_turret_owner 	EV_ENT_owner
#define EV_ENT_turret_ammobar	EV_ENT_euser2
#define EV_ENT_turret_ranger	EV_ENT_euser3

new gszTurretsConfigFile[] = "addons/amxmodx/configs/td_turrets_config.cfg"
new gszSoundConfigFile[] = "addons/amxmodx/configs/td_sounds.cfg";
new gszLogFile[] = "Tower Defense.log"
new gszPrefix[] = "[TD:Wiezyczki]"

new MAX_MAP_TURRET

enum e_TurretsType {
	TURRET_NONE,
	TURRET_NORMAL,
	TURRET_LASER,
	TURRET_LIGHTING
}

enum e_Sound {
	SOUND_TURRET_NORMAL_FIRE_1,
	SOUND_TURRET_NORMAL_FIRE_2,
	SOUND_TURRET_LASER_FIRE_1,
	SOUND_TURRET_LASER_FIRE_2,
	SOUND_TURRET_LIGHTING_FIRE_1,
	SOUND_TURRET_LIGHTING_FIRE_2,
	SOUND_TURRET_START_FIRE,
	SOUND_TURRET_STOP_FIRE,
	SOUND_TURRET_PLANT,
	SOUND_TURRET_LOWAMMO,
	SOUND_TURRET_NOAMMO,
	SOUND_MENU_SELECT
}

enum e_Cvar {
	CVAR_TURRET_NORMAL_AMMO,
	CVAR_TURRET_LASER_AMMO,
	CVAR_TURRET_LIGHTING_AMMO,
	CVAR_TURRET_NORMAL_AMMO_NUM,
	CVAR_TURRET_LASER_AMMO_NUM,
	CVAR_TURRET_LIGHTING_AMMO_NUM,
	CVAR_TURRET_MOVE_COST,
	CVAR_TURRET_SHOW_AMMO_BAR,
	CVAR_TURRET_MOVE_ACTIVATION,
	CVAR_TURRET_RELOAD_TIME,
	CVAR_TURRET_INSTALL_TIME,
	CVAR_TURRET_UPGRADE_TIME,
	CVAR_TURRET_CHANGE_ENEMY_TIME,
	CVAR_TURRET_SHOW_AMMO
}
enum e_CvarValue {
	TURRET_NORMAL_AMMO,
	TURRET_LASER_AMMO,
	TURRET_LIGHTING_AMMO,
	TURRET_NORMAL_AMMO_NUM,
	TURRET_LASER_AMMO_NUM,
	TURRET_LIGHTING_AMMO_NUM,
	TURRET_MOVE_COST,
	TURRET_SHOW_AMMO_BAR,
	Float:TURRET_MOVE_ACTIVATION,
	Float:TURRET_RELOAD_TIME,
	Float:TURRET_INSTALL_TIME,
	Float:TURRET_UPGRADE_TIME,
	Float:TURRET_CHANGE_ENEMY_TIME,
	TURRET_SHOW_AMMO
}
enum e_Tasks {
	TASK_UPGRADE_TURRET = 1451,
	TASK_CREATE_TURRET_INFO = 1520
}

new const gszTurretsName[e_TurretsType][] =
{
	"BRAK",
	"ZWYKLA",
	"LASER",
	"PIORUN"
}

new const gszTurretsShopName[MAX_PLAYER_TURRET][] = {
	"Wiezyczka 1",
	"Wiezyczka 2",
	"Wiezyczka 3"
}

new const giSlotCost[MAX_PLAYER_TURRET] = {
	10,
	25,
	30
}

new gServerTurretsNum
new gTurretsFreqData[e_TurretsType]
new gTurretsPriceData[e_TurretsType][5]
new gTurretsDamageData[e_TurretsType][5][2]
new gTurretsRangeData[e_TurretsType][5]

new gCvarInfo[e_Cvar]
new gCvarValue[e_CvarValue]

new gTasks[e_Tasks]
new gSounds[e_Sound][128]

new e_TurretsType:gPlayerTurretType[33][MAX_PLAYER_TURRET]

new bool:gPlayerSlot[33][MAX_PLAYER_TURRET]
new bool:gPlayerAlarmStatus[33][MAX_PLAYER_TURRET]
new bool:gPlayerTurretIsUpgrading[33][MAX_PLAYER_TURRET];

new gPlayerTurretEnt[33][MAX_PLAYER_TURRET]
new gPlayerTurretLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretDamageLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretRangeLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretAmmo[33][MAX_PLAYER_TURRET]
new gPlayerTurretMove[33]
new gPlayerTurretNum[33]; 

new Float:gfPlayerHudGameTime[33];
new Float:gfPlayerAmmoBarScale[33];
new giPlayerAlarmValue[33];

new gSpriteLaserBeam;
new gSpriteRanger[] = "sprites/TD/ranger.spr"
new gShellIndex
new gSpriteAmmoBar[] = "sprites/TD/turrets.spr"
new gHudMessage;

public plugin_precache() 
{
	LoadSound()
	for(new i; i < _:e_Sound ; i++) {
		precache_sound(gSounds[e_Sound:i]);
	}
	precache_model("models/TD/sentrygun_1.mdl")
	precache_model("models/TD/sentrygun_2.mdl")
	precache_model("models/TD/sentrygun_3.mdl")
	precache_model("models/TD/sentrygun_4.mdl")
	precache_model("models/TD/sentrygun_5.mdl")
	
	gShellIndex = precache_model("models/rshell_big.mdl")
	gSpriteLaserBeam = precache_model("sprites/TD/laserbeam.spr")
	
	precache_model(gSpriteRanger)
	precache_model(gSpriteAmmoBar)
}
public plugin_natives() {
	register_native("td_set_ammobar_scale", "ChangeAmmoBarScale", 1);
	register_native("td_set_alarm_value", "ChangeAlarmValue", 1);
}

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)

	if(td_get_game_status() == GAME_NOT_AVAILABLE)
		set_fail_state("Gra jest niemozliwa, jesli nie wiesz co jest przyczyna, wlacz debug mode w tdnew");
		
	register_forward(FM_AddToFullPack, "fwAddToFullPack", 1)
	
	register_think("turret", "TurretThink")
	register_clcmd("say /turrets", "cmdmenuTurrets");
	
	gHudMessage = CreateHudSyncObj();
	
	LoadCvars()
	LoadTurretsConfig()
}

public LoadCvars() {
	/* Cvary */
	
	gCvarInfo[CVAR_TURRET_NORMAL_AMMO] = CvarRegister("td_turret_normal_ammo_cost", "15", _, _, true, 0.0, false, _, true)
	gCvarInfo[CVAR_TURRET_LASER_AMMO] = CvarRegister("td_turret_laser_ammo_cost", "20", _, _, true, 0.0, false, _, true)
	gCvarInfo[CVAR_TURRET_LIGHTING_AMMO] = CvarRegister("td_turret_lighting_ammo_cost", "25", _, _, true, 0.0, false, _, true)
	
	gCvarInfo[CVAR_TURRET_NORMAL_AMMO_NUM] = CvarRegister("td_turret_normal_ammo_num", "250", _, _, true, 0.0, false, _, true)
	gCvarInfo[CVAR_TURRET_LASER_AMMO_NUM] = CvarRegister("td_turret_laser_ammo_num", "100", _, _, true, 0.0, false, _, true)
	gCvarInfo[CVAR_TURRET_LIGHTING_AMMO_NUM] = CvarRegister("td_turret_lighting_ammo_num", "400", _, _, true, 0.0, false, _, true)
	
	gCvarInfo[CVAR_TURRET_MOVE_COST] = CvarRegister("td_turret_move_cost", "10", _, _, true, 0.0, false, _, true)
	gCvarInfo[CVAR_TURRET_MOVE_ACTIVATION] = CvarRegister("td_turret_move_activation", "3.0", _, _, true, 0.1, false, _, true)
	
	gCvarInfo[CVAR_TURRET_SHOW_AMMO_BAR] = CvarRegister("td_turret_show_ammo_bar", "1", _, _, true, 0.0, true,2.0, true) // 0 - wylaczone ; 1 - tylko wlasciciel ; 2 - wszyscy
	
	gCvarInfo[CVAR_TURRET_RELOAD_TIME] = CvarRegister("td_turret_reload_time", "3.0", _, _, true, 0.1, false, _, true)
	gCvarInfo[CVAR_TURRET_INSTALL_TIME] = CvarRegister("td_turret_install_time", "1.5", _, _, true, 0.1, false, _, true)
	gCvarInfo[CVAR_TURRET_UPGRADE_TIME] = CvarRegister("td_turret_upgrade_time", "2.0", _, _, true, 0.1, false, _, true)
	
	gCvarInfo[CVAR_TURRET_SHOW_AMMO] = CvarRegister("td_turret_show_ammo", "2", _, _, true, 0.0, true, 2.0, true) // 0 - nie | 1 - tylko twoich wie¿yczek | 2 - wszystkic wie¿yczek
	
	gCvarInfo[CVAR_TURRET_CHANGE_ENEMY_TIME] = CvarRegister("td_turret_change_enemy_time", "0.35", _, _, true, 0.01, false, _, true)
	
	
	for(new i; i < _:e_Cvar;i++) {
		if(e_Cvar:i == CVAR_TURRET_MOVE_ACTIVATION || e_Cvar:i == CVAR_TURRET_RELOAD_TIME || e_Cvar:i == CVAR_TURRET_INSTALL_TIME || e_Cvar:i ==  CVAR_TURRET_UPGRADE_TIME || e_Cvar:i ==  CVAR_TURRET_CHANGE_ENEMY_TIME) 
			CvarCache(gCvarInfo[e_Cvar:i], CvarType_Float, gCvarValue[e_CvarValue:i])
		else
			CvarCache(gCvarInfo[e_Cvar:i], CvarType_Int, gCvarValue[e_CvarValue:i])
	}
}

public client_disconnect(id)
{
	for(new i; i < MAX_PLAYER_TURRET; i++)
		DeleteTurret(id, gPlayerTurretEnt[id][i])
	
}
public fwAddToFullPack(es_handle, e, ENT, HOST, hostflags, player, set)
{
	if(player || !is_user_connected(HOST) || !is_user_alive(HOST)) 
		return FMRES_IGNORED;
		

	
	if(td_is_ranger(ENT))
	{	 
		if(entity_get_edict(ENT, EV_ENT_turret_owner) == HOST)
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAdd)
			set_es(es_handle, ES_RenderAmt, 255)
			set_es(es_handle, ES_RenderColor, 255, 0, 0)
			set_es(es_handle, ES_RenderFx, kRenderFxNone)
		}
		else
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAdd)
			set_es(es_handle, ES_RenderAmt, 0)
			set_es(es_handle, ES_RenderColor, 0, 0, 0)
			set_es(es_handle, ES_RenderFx, kRenderFxNone)
		}
	}
	else if(td_is_ammobar(ENT))
	{
		for(new i ; i < MAX_PLAYER_TURRET ; i++) {
			if( entity_get_edict(gPlayerTurretEnt[HOST][i], EV_ENT_turret_ammobar))
				entity_set_float( entity_get_edict(gPlayerTurretEnt[HOST][i], EV_ENT_turret_ammobar), EV_FL_scale, gfPlayerAmmoBarScale[HOST])
		}
		
		
		if(gCvarValue[TURRET_SHOW_AMMO_BAR] == 1) {
			if(entity_get_edict(ENT, EV_ENT_turret_owner) == HOST)
			{
				set_es(es_handle, ES_RenderMode, kRenderTransAdd)
				set_es(es_handle, ES_RenderAmt, 255)
				set_es(es_handle, ES_RenderFx, kRenderFxNone)
			}
			else
			{
				set_es(es_handle, ES_RenderMode, kRenderTransAdd)
				set_es(es_handle, ES_RenderAmt, 0)
				set_es(es_handle, ES_RenderFx, kRenderFxNone)
			}
		}
	}
	return FMRES_IGNORED;
}

public client_PostThink(id) {
	if(is_user_alive(id)) {
		if(get_gametime() > gfPlayerHudGameTime[id] + 1.0) {
			if(td_is_turret_on_server()) {
				static iEntList[3];
				if(find_sphere_class(id, "turret", 20.0, iEntList, 2)) {
					new szText[75];
					new szTemp[33];
					new iOwner = entity_get_edict(iEntList[0], EV_ENT_turret_owner) 
					get_user_name(iOwner, szTemp, charsmax(szTemp))
					
					formatex(szText, charsmax(szText), "Typ Wiezyczki: %s^nWiezyczka gracza: %s", gszTurretsName[e_TurretsType:entity_get_int(iEntList[0], EV_INT_turret_type)], szTemp)
					
					if(iOwner  ==id  && gCvarValue[TURRET_SHOW_AMMO] == 1) {
						formatex(szTemp, charsmax(szTemp), "^nAmunicja: %d",  gPlayerTurretAmmo[id][entity_get_int(iEntList[0], EV_INT_turret_id)])
					} else if(gCvarValue[TURRET_SHOW_AMMO] == 2) {
						formatex(szTemp, charsmax(szTemp), "^nAmunicja: %d",  gPlayerTurretAmmo[iOwner][entity_get_int(iEntList[0], EV_INT_turret_id)])
					}
					if(gCvarValue[TURRET_SHOW_AMMO] != 0)
						add(szText, charsmax(szText), szTemp)
					
					set_hudmessage(212, 255, 255, -1.0, 0.85, 0, 6.0, 1.1)
					ShowSyncHudMsg(id, gHudMessage, szText);
	
					gfPlayerHudGameTime[id] = get_gametime();
				}
			}
		}
		if(is_valid_ent(gPlayerTurretMove[id])) {
			static Float:fOrigin[3]
			
			get_origin_from_dist_player(id, 70.0, fOrigin)
			entity_set_model(gPlayerTurretMove[id], "models/TD/sentrygun_2.mdl")
			entity_set_origin(gPlayerTurretMove[id], fOrigin)
			drop_to_floor(gPlayerTurretMove[id])
			
			entity_get_vector(gPlayerTurretMove[id], EV_VEC_origin, fOrigin)
			static Origin[3], Float:fTempOrigin[3]
			get_user_origin(id, Origin, 3)
			IVecFVec(Origin, fTempOrigin)
			
			TurretTurnToTarget(gPlayerTurretMove[id], 0, 1, fTempOrigin);
			
			new entlist[3]
			
			if(find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin) && entlist[0] != gPlayerTurretMove[id]) 
				entity_set_model(gPlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			else if(find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin))
				entity_set_model(gPlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			if(!fm_is_ent_visible(id, gPlayerTurretMove[id]))
				entity_set_model(gPlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			
			fOrigin[2] += 1.0
		
			entity_set_origin(entity_get_edict(gPlayerTurretMove[id], EV_ENT_turret_ranger), fOrigin)
		}
			
	}
	
}
public cmdmenuTurrets(id) {
	if(!is_user_connected(id)  || !is_user_alive(id))
		return PLUGIN_CONTINUE;
		
	new szFormat[128], szAlarm[33];
	
	new menu = menu_create("Wybierz :", "cmdmenuTurretsH")
	new cb = menu_makecallback("cmdmenuTurretsCb");
	
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	formatex(szAlarm,32, "\r [\w LOW AMMO\r ]")
	
	for(new i ; i < MAX_PLAYER_TURRET; i++)
	{
		DeleteTurretRanger(gPlayerTurretEnt[id][i])
		if(gServerTurretsNum >= MAX_SERVER_TURRET && gPlayerTurretEnt[id][i] <= 0)
			formatex(szFormat, charsmax(szFormat), "Slot %d \r [ LIMIT SERWERA ]", i+1)
		else if(gServerTurretsNum >= MAX_MAP_TURRET && gPlayerTurretEnt[id][i] <= 0)
			formatex(szFormat, charsmax(szFormat), "Slot %d \r [ LIMIT MAPY ]", i+1)
		else if(gPlayerSlot[id][i] == false && iGold < giSlotCost[i])
			formatex(szFormat, charsmax(szFormat), "Slot %d \r[ %d \yZLOTA\r ]", i+1, giSlotCost[i])
		else if(gPlayerSlot[id][i] == false && iGold >= giSlotCost[i])
			formatex(szFormat, charsmax(szFormat), "Slot %d \r[\y KUP SLOT ZA \r%d\y ZLOTA\r ]", i+1, giSlotCost[i])
		/* Jeœli kupi³ slot */
		else if(gPlayerSlot[id][i]) {
			/* Jeœli nie ma kupionej wie¿yczki */
			if(gPlayerTurretEnt[id][i] <= 0)
				formatex(szFormat, charsmax(szFormat), "Slot %d \r[\y KUP WIEZYCZKE\r ]", i+1)
			else if(gPlayerTurretEnt[id][i] > 0)
				formatex(szFormat, charsmax(szFormat), "%s \r[ \y%d lvl\r ] [ \y%s\r ]", gszTurretsShopName[i], gPlayerTurretLevel[id][i], gszTurretsName[gPlayerTurretType[id][i]])
		}
		
		if(gPlayerAlarmStatus[id][i] == true) {
			add(szFormat, 127, szAlarm)
		}
		
		menu_additem(menu, szFormat, _, _, cb)
	}
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz");
	menu_display(id, menu)
	
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);	
	
	return PLUGIN_CONTINUE
}

public cmdmenuTurretsCb(id, menu, item) { 
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	for(new i ; i < MAX_PLAYER_TURRET; i++)
	{	
		if((gServerTurretsNum >= MAX_SERVER_TURRET  || gServerTurretsNum >= MAX_MAP_TURRET) && gPlayerTurretEnt[id][i] <= 0 && item == i)
			return ITEM_DISABLED
		else if(gPlayerSlot[id][i] == false && iGold < giSlotCost[i] && item == i)
			return ITEM_DISABLED
	}
	
	return ITEM_ENABLED
}
public cmdmenuTurretsH(id, menu, item) {
	if(item == MENU_EXIT || !is_user_alive(id)) {
		menu_destroy(menu)
		client_cmd(id, "say /menu")
		return PLUGIN_CONTINUE
	}
	
	if(!gPlayerSlot[id][item]) {
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-giSlotCost[item])
		
		ColorChat(id, GREEN, "%s^x01 Kupiles^x04 slot %d^x01 na wiezyczke. Na tym slocie mozesz posiadac 1 wiezyczke..", gszPrefix, item+1)
		
		gPlayerSlot[id][item] = true
		
		client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
		
		cmdmenuTurrets(id);
		return PLUGIN_CONTINUE 
	}
	
	if(gPlayerSlot[id][item] && gPlayerTurretEnt[id][item] <= 0) {
		menuBuyTurret(id, item)
	}
	else if(gPlayerSlot[id][item] && gPlayerTurretEnt[id][item] > 0) {
		menuTurret(id, item)
	}
	
		
	return PLUGIN_CONTINUE;
}

public menuBuyTurret(id, sentryid)
{
	if(is_valid_ent(entity_get_edict(gPlayerTurretMove[id], EV_ENT_turret_ranger)))
		remove_entity(entity_get_edict(gPlayerTurretMove[id], EV_ENT_turret_ranger))
	
	if(is_valid_ent(gPlayerTurretMove[id]))
		remove_entity(gPlayerTurretMove[id])
	
	gPlayerTurretMove[id] = 0
	new menu = menu_create("Wybierz typ wiezyczki: ", "menuBuyTurretH")
	new cb = menu_makecallback("menuBuyTurretCb")
	
	new szFormat[64]
	new szData[4]
	
	num_to_str(sentryid, szData, 3)
	
	for(new i = 1; i < _:e_TurretsType; i++)
	{
		formatex(szFormat, 63, "%s \r[ \y%d\w ZLOTA\r ]", gszTurretsName[e_TurretsType:i], gTurretsPriceData[e_TurretsType:i][0])
		menu_additem(menu, szFormat, szData, _, cb)
	}
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	menu_setprop(menu, MPROP_EXITNAME, "Wroc")
	menu_display(id, menu)
}
public menuBuyTurretCb(id, menu, item)
{
	for(new i = 1; i < _:e_TurretsType; i++)
		if(td_get_user_info(id, PLAYER_GOLD) < gTurretsPriceData[e_TurretsType:i][0] && item == i-1)
			return ITEM_DISABLED
	return ITEM_ENABLED
}

public menuBuyTurretH(id, menu, item)
{
	if(item == MENU_EXIT || !is_user_alive(id))
	{
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	new acces, szSentryId[4], name[3], cb
	menu_item_getinfo(menu, 0, acces, szSentryId, 3, name, 2, cb)
	
	new iMenu = menu_create("Gdzie chcesz postawic wiezyczke?", "menuBuyTurret2H")
	
	new szType[4]
	num_to_str(item+1, szType, 3)
	
	menu_additem(iMenu, "Postaw tutaj", szSentryId)
	menu_additem(iMenu, "Wstecz", szType)
	menu_display(id, iMenu)
	
	if(!gPlayerTurretMove[id])
		CreateMoveEffectTurret(id, e_TurretsType:(item+1), 0)
		
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	return PLUGIN_CONTINUE
}

public menuBuyTurret2H(id, menu, item)
{
	new acces, szSentryId[4], szType[4], cb
	
	menu_item_getinfo(menu, 0, acces, szSentryId, 3, szType, 3, cb)
	new turret = str_to_num(szSentryId)
	
	menu_item_getinfo(menu,1, acces, szType, 3, szSentryId, 3, cb)
	new Type = str_to_num(szType)
	
	if(item == MENU_EXIT || !is_user_alive(id) || item == 1) {
		menu_destroy(menu)
		menuBuyTurret(id, turret)
		return PLUGIN_CONTINUE
	}
	
	new ent = gPlayerTurretMove[id] , Float:fOrigin[3], entlist[3]
	
	entity_get_vector(ent, EV_VEC_origin, fOrigin)
	
	if(find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin)) {
		if((entlist[0] == ent && entlist[1] != ent))
			goto repair;
		client_print(id, print_center, "Nie mozesz stawiac wiezyczek zbyt blisko siebie!")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE
	}
	repair:
	if(find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin)) {
		client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE
	}
	if(!fm_is_ent_visible(id, ent)) {
		client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE		
	}
			
	if(is_valid_ent(entity_get_edict(gPlayerTurretMove[id], EV_ENT_turret_ranger)))
		remove_entity(entity_get_edict(gPlayerTurretMove[id], EV_ENT_turret_ranger))
	
	if(is_valid_ent(gPlayerTurretMove[id]))
		remove_entity(gPlayerTurretMove[id])
	
	gPlayerTurretMove[id] = 0
	
	CreateTurret(id, turret, Type)
	
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	return PLUGIN_CONTINUE		
}

public CreateMoveEffectTurret(id , e_TurretsType:iTurretType, iTurretEnt)
{
	if(!is_user_alive(id) || iTurretType == TURRET_NONE)
		return
		
	new Float:fOrigin[3], Float:Angles[3]
	entity_get_vector(id, EV_VEC_origin, fOrigin)

	get_origin_from_dist_player(id, 70.0, fOrigin)

	if(!is_valid_ent(iTurretEnt)) {
		new iEnt  = create_entity("func_wall")
		
		entity_set_string(iEnt, EV_SZ_classname, "turret_pre")
		entity_set_model(iEnt, "models/TD/sentrygun_2.mdl")
		entity_set_vector(iEnt, EV_VEC_origin, fOrigin)
		
		fm_set_rendering(iEnt, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		entity_set_int(iEnt, EV_INT_solid, SOLID_NOT)
	
		new iRanger = create_entity("env_sprite")
		
		entity_set_edict(iEnt, EV_ENT_turret_ranger, iRanger)
		
		entity_set_string(iRanger, EV_SZ_classname, "ranger")
		entity_set_model(iRanger, gSpriteRanger)
		entity_set_edict(iRanger, EV_ENT_turret_owner, id)
		
		/* K¹t */
		
		entity_get_vector(iRanger, EV_VEC_angles, Angles)
		Angles[0] += 90
		
		fOrigin[2] += 1.0
		
		entity_set_origin(iRanger, fOrigin)
		entity_set_vector(iRanger, EV_VEC_angles, Angles)
		
		entity_set_float(iRanger, EV_FL_scale, gTurretsRangeData[iTurretType][0]/250.0)
		fm_set_rendering(iRanger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		gPlayerTurretMove[id] = iEnt
	}
	else {		
		entity_set_model(iTurretEnt, "models/TD/sentrygun_2.mdl")
		entity_set_vector(iTurretEnt, EV_VEC_origin, fOrigin)
		entity_set_int(iTurretEnt, EV_INT_solid, SOLID_NOT)
		
		new iRanger = create_entity("env_sprite")
		
		entity_set_edict(iTurretEnt, EV_ENT_turret_ranger, iRanger)
		
		fm_set_rendering(iTurretEnt, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		entity_set_string(iRanger, EV_SZ_classname, "ranger")
		entity_set_model(iRanger, gSpriteRanger)
		entity_set_edict(iRanger, EV_ENT_turret_owner, id)
		
		/* K¹t */
		
		entity_get_vector(iRanger, EV_VEC_angles, Angles)
		Angles[0] += 90
		
		fOrigin[2] += 1.0
		
		entity_set_origin(iRanger, fOrigin)
		entity_set_vector(iRanger, EV_VEC_angles, Angles)
		
		entity_set_float(iRanger, EV_FL_scale, gTurretsRangeData[iTurretType][gPlayerTurretRangeLevel[id][entity_get_int(iTurretEnt, EV_INT_turret_id)]]/250.0)
		fm_set_rendering(iRanger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		gPlayerTurretMove[id] = iTurretEnt
	}
		
}
public menuTurret(id, turret) {
	if(!is_user_alive(id)) {
		return PLUGIN_CONTINUE
	}
		
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	new szTitle[200], szAmmo[64], szDelete[33], szNextMenu[64], szMove[64]
	
	CreateTurretRanger(gPlayerTurretEnt[id][turret])
	
	new e_TurretsType:type = e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret],EV_INT_turret_type)
	
	formatex(szTitle, 199, "\r[\y %s \r] [\y %s\r ]^n[\y Poziom: \w%d\r ] [\y Amunicja: \w%d\r ]^n[\y Zadawane obr: \w%d\y ~\w %d\r ] [ \yZasieg:\w %d\r ]", 
	gszTurretsShopName[turret], gszTurretsName[type], gPlayerTurretLevel[id][turret], gPlayerTurretAmmo[id][turret]?gPlayerTurretAmmo[id][turret]:0,
	gTurretsDamageData[type][gPlayerTurretDamageLevel[id][turret]][0], gTurretsDamageData[type][gPlayerTurretDamageLevel[id][turret]][1],
	gTurretsRangeData[type][gPlayerTurretRangeLevel[id][turret]])
	
	if(type == TURRET_NORMAL)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]",gCvarValue[TURRET_NORMAL_AMMO_NUM], gCvarValue[TURRET_NORMAL_AMMO])
	if(type == TURRET_LASER)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]", gCvarValue[TURRET_LASER_AMMO_NUM], gCvarValue[TURRET_LASER_AMMO])
	if(type == TURRET_LIGHTING)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]", gCvarValue[TURRET_LIGHTING_AMMO_NUM], gCvarValue[TURRET_LIGHTING_AMMO])
	
	if(gPlayerTurretIsUpgrading[id][turret])
		formatex(szNextMenu, 63, "Trwa modernizacja wiezyczki,,,")
	else 
		formatex(szNextMenu, 63, "\yUlepsz Wiezyczke")
	
	formatex(szDelete, 32, "Usun Wiezyczke")
	formatex(szMove, 63, "Przenies Wiezyczke \r[\w %d\y Zlota\r ]", gCvarValue[TURRET_MOVE_COST])
	
	new menu = menu_create(szTitle, "menuTurretH")
	new cb = menu_makecallback("menuTurretCb")
	
	new szData[4];
	num_to_str(turret, szData, 3)
	
	menu_additem(menu, szAmmo, szData, _, cb);
	menu_additem(menu, szDelete, _, _, cb);
	menu_additem(menu, szMove, _, _, cb)
	menu_additem(menu, szNextMenu, _, _, cb)
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu);
	return PLUGIN_CONTINUE
}

public menuTurretCb(id, menu, item)
{
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	new e_TurretsType:type = e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)
	
	new gold = _:td_get_user_info(id, PLAYER_GOLD)
	
	if(item == 0)
	{
		if(type == TURRET_NORMAL)
		{
			if(gCvarValue[TURRET_NORMAL_AMMO] > gold)
				return ITEM_DISABLED
		}
		else if(type == TURRET_LASER)
		{
			if(gCvarValue[TURRET_LASER_AMMO] > gold)
				return ITEM_DISABLED
		}
		else if(type == TURRET_LIGHTING)
		{
			if(gCvarValue[TURRET_LIGHTING_AMMO] > gold)
				return ITEM_DISABLED
		}
	}
	else if(item == 2 && gold < gCvarValue[TURRET_MOVE_COST])
		return ITEM_DISABLED
	
	if(item == 3 && gPlayerTurretIsUpgrading[id][turret] == true)
		return ITEM_DISABLED
		
	return ITEM_ENABLED
}
public menuTurretH(id, menu, item) {
	
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT || !is_user_alive(id)) {
		client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
		DeleteTurretRanger(gPlayerTurretEnt[id][turret])

		if(is_user_alive(id))
			cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	new e_TurretsType:type = e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)
	if(item == 0)
	{
		switch(type)
		{
			case TURRET_NORMAL:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gCvarValue[TURRET_NORMAL_AMMO])
				gPlayerTurretAmmo[id][turret] += gCvarValue[TURRET_NORMAL_AMMO_NUM]+1
			}
			case TURRET_LASER:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gCvarValue[TURRET_LASER_AMMO])
				gPlayerTurretAmmo[id][turret] += gCvarValue[TURRET_LASER_AMMO_NUM]+1
			}
			case TURRET_LIGHTING:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gCvarValue[TURRET_LIGHTING_AMMO])
				gPlayerTurretAmmo[id][turret] += gCvarValue[TURRET_LIGHTING_AMMO_NUM]+1
			}
		}
		ColorChat(id, GREEN, "%s^x01 Trwa przeladowywanie wiezyczki...", gszPrefix)
		
		if(gPlayerTurretAmmo[id][turret] > giPlayerAlarmValue[id]) {
			gPlayerAlarmStatus[id][turret] = false;
		}
		menuTurret(id, turret);
		ChangeAmmoBar(gPlayerTurretEnt[id][turret], -2, 0)
		entity_set_float(gPlayerTurretEnt[id][turret], EV_FL_nextthink, get_gametime() + gCvarValue[TURRET_RELOAD_TIME]);
		
		client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	}
	else if(item == 1)
		menuConfirmDelete(id, turret)
	else if(item == 2) {
		new Float:fOrigin[3]
		entity_get_vector(gPlayerTurretEnt[id][turret], EV_VEC_origin, fOrigin)
		entity_set_vector(gPlayerTurretEnt[id][turret], EV_VEC_oldorigin, fOrigin)
		menuMoveTurret(id, gPlayerTurretEnt[id][turret])
	}
	else if(item == 3)
		menuUpgradeTurret(id, turret)
	return PLUGIN_CONTINUE
}

public menuConfirmDelete(id, turret)
{
	DeleteTurretRanger(gPlayerTurretEnt[id][turret])
	
	new menu = menu_create("Czy napewno chcesz usunac te wiezyczke?^n\rZadne koszty nie zostana zwrocone!", "menuConfirmDeleteH")
	
	new szData[4]
	num_to_str(turret, szData, 3)
	menu_additem(menu, "\yTak", szData)
	menu_additem(menu, "\rWstecz")
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	
	menu_display(id, menu)
	
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
}

public menuConfirmDeleteH(id, menu, item)
{
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT || item == 1)
	{
		if(is_user_alive(id))
			menuTurret(id, turret)
		return PLUGIN_CONTINUE
	}
	if(item == 0)
		DeleteTurret(id, gPlayerTurretEnt[id][turret])
	
	return PLUGIN_CONTINUE
}
public menuMoveTurret(id, ent)
{	
	if(!td_is_turret(ent)) {
		new szClass[16];
		entity_get_string(ent, EV_SZ_classname, szClass, 15)
		return PLUGIN_CONTINUE
	}
		
	if(!is_user_alive(id))
		return PLUGIN_CONTINUE
	
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	entity_set_float(ent, EV_FL_nextthink, 0.0)
	
	if(!gPlayerTurretMove[id]) {
		
		DeleteTurretRanger(ent)
		RemoveAmmoBar(ent)
		CreateMoveEffectTurret(id, e_TurretsType:gPlayerTurretType[id][entity_get_int(ent, EV_INT_turret_id)], ent)
	}

	new szTitle[64];
	formatex(szTitle, 63, "\wPrzeniesienie kosztuje \y%d\w zlota.^nChcesz ja przeniesc?", gCvarValue[TURRET_MOVE_COST])
	new menu = menu_create(szTitle, "menuMoveTurretH")
	
	new szData[4];
	num_to_str(entity_get_int(ent, EV_INT_turret_id), szData, 3)
	menu_additem(menu, "\yPrzenies tutaj", szData)
	menu_additem(menu, "\rWstecz")
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu)
	return PLUGIN_CONTINUE
}
public menuMoveTurretH(id, menu, item)
{
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT || item == 1 || !is_user_alive(id)) {
		
		gPlayerTurretMove[id] = 0
		
		new ranger = entity_get_edict(gPlayerTurretEnt[id][turret], EV_ENT_turret_ranger)
		new Float:fOrigin[3]
		
		if(is_valid_ent(ranger))
			remove_entity(ranger)
		
		entity_set_edict(gPlayerTurretEnt[id][turret], EV_ENT_turret_ranger, 0)
		
		entity_get_vector(gPlayerTurretEnt[id][turret], EV_VEC_oldorigin, fOrigin)
		entity_set_vector(gPlayerTurretEnt[id][turret], EV_VEC_origin, fOrigin)
		new szModel[64];
		formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", gPlayerTurretLevel[id][turret])
		
		entity_set_model(gPlayerTurretEnt[id][turret], szModel)
		drop_to_floor(gPlayerTurretEnt[id][turret])
		CreateAmmoBar(gPlayerTurretEnt[id][turret])
		entity_set_float(gPlayerTurretEnt[id][turret], EV_FL_nextthink, get_gametime()+0.5);
		DeleteTurretRanger(gPlayerTurretEnt[id][turret])
		
		menuTurret(id, turret)
		return PLUGIN_CONTINUE
		
	}
	else if(item == 0) {
		new Float:fOrigin[3],Float:fOrigin2[3], Origin[3]
		get_origin_from_dist_player(id, 70.0, fOrigin)
		FVecIVec(fOrigin, Origin)
		
		new ent = gPlayerTurretEnt[id][turret], entlist[3]
		if(find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin)) {
			if((entlist[0] == ent && entlist[1] != ent))
				goto repair;
			client_print(id, print_center, "Nie mozesz stawiac wiezyczek zbyt blisko siebie!")
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		repair:
		if(find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin)) {
			client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		if(!fm_is_ent_visible(id, ent)) {
			client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE		
		}
		gPlayerTurretMove[id] = 0
		
		new ranger = entity_get_edict(ent, EV_ENT_turret_ranger)
		if(is_valid_ent(ranger))
			remove_entity(ranger)
		entity_set_edict(ent, EV_ENT_turret_ranger, 0)
		//do
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		entity_get_vector(ent, EV_VEC_origin, fOrigin2) 
		
		FVecIVec(fOrigin2, Origin)
		//od
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		entity_set_origin(ent, fOrigin)
		drop_to_floor(ent)
		new szModel[64];
		formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", gPlayerTurretLevel[id][turret])
		
		entity_set_model(gPlayerTurretEnt[id][turret], szModel)
		CreateAmmoBar(ent)
		entity_set_float(ent, EV_FL_nextthink, get_gametime() +  gCvarValue[TURRET_MOVE_ACTIVATION])
		
		ColorChat(id, GREEN, "%s^x01 Twoja wiezyczka uzbroi sie za^x04 %0.1f^x01 sek.", gszPrefix,  gCvarValue[TURRET_MOVE_ACTIVATION])
		
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gCvarValue[TURRET_MOVE_COST])
		menuTurret(id, turret)
	}
	return PLUGIN_CONTINUE
}
public DeleteTurret(id, iEnt)
{
	if(!is_user_alive(id) || !is_valid_ent(iEnt))
		return PLUGIN_CONTINUE
		
	new Float:fOrigin[3], Origin[3]
	entity_get_vector(iEnt, EV_VEC_origin, fOrigin)
	FVecIVec(fOrigin, Origin)
	
	message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) //message begin
	write_byte(TE_IMPLOSION)
	write_coord(Origin[0]) // start position
	write_coord(Origin[1])
	write_coord(Origin[2]+30)
	write_byte(100) 
	write_byte(45) 
	write_byte(5) 
	message_end()

	new sentryid = entity_get_int(iEnt, EV_INT_turret_id)
	DeleteTurretRanger(gPlayerTurretEnt[id][sentryid])
	
	gPlayerTurretType[id][sentryid] = TURRET_NONE
	gPlayerTurretEnt[id][sentryid] = 0
	gPlayerTurretLevel[id][sentryid] = 0
	gPlayerTurretAmmo[id][sentryid] = 0
	gPlayerTurretNum[id]--
	gServerTurretsNum--
	
	entity_set_edict(iEnt, EV_ENT_turret_owner, 0)
	entity_set_int(iEnt, EV_INT_turret_id, 0)
	entity_set_int(iEnt, EV_INT_turret_type, 0)
	entity_set_int(iEnt, EV_INT_turret_firemode, 0)
	
	RemoveAmmoBar(iEnt)
	
	entity_set_float(iEnt, EV_FL_nextthink, 0.0);
	
	remove_entity(iEnt)
	cmdmenuTurrets(id)
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	return PLUGIN_CONTINUE
}

public menuUpgradeTurret(id, turret)
{
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
	
	client_cmd(id, "spk sound/%s", gSounds[SOUND_MENU_SELECT]);
	
	static szTitle[200], szDamage[80], szRange[80]

	CreateTurretRanger(gPlayerTurretEnt[id][turret])

	new e_TurretsType:type = e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)
	new damage_level = gPlayerTurretDamageLevel[id][turret]
	new range_level = gPlayerTurretRangeLevel[id][turret]

	formatex(szTitle, 199, "\r[\y %s \r] [\y %s\r ]^n[\y Poziom: \w%d\r ]^n[\y Zadawane obr: \w%d\y ~\w %d\r ] [ \yZasieg\w %d\r ]", 
	gszTurretsShopName[turret], gszTurretsName[type], gPlayerTurretLevel[id][turret],
	gTurretsDamageData[type][damage_level][0], gTurretsDamageData[type][damage_level][1],
	gTurretsRangeData[type][range_level])

	if(damage_level+1 >= 5)
		formatex(szDamage,  79, "Zwieksz Obrazenia\r [ \yMAX \w~ \yMAX \r]")
	else if(damage_level < 5)
		formatex(szDamage,  79, "Zwieksz Obrazenia\r [ \y%d\w Zlota\r ] [\w +\y%d \w~ \w+\y%d\r ]", gTurretsPriceData[type][damage_level+1],
		(gTurretsDamageData[type][damage_level+1][0] - gTurretsDamageData[type][damage_level][0]), 
		(gTurretsDamageData[type][damage_level+1][1] - gTurretsDamageData[type][damage_level][1]))

	if(range_level+1 >= 5)
		formatex(szRange,  63, "Zwieksz Zasieg\r [ \yMAX\r ]")
	else if(range_level < 5)
		formatex(szRange,  63, "Zwieksz Zasieg\r [ \y%d\w Zlota\r ] [\w +\y%d\r ]", gTurretsPriceData[type][range_level+1],
		(gTurretsRangeData[type][range_level+1] - gTurretsRangeData[type][range_level]))


	new menu = menu_create(szTitle, "menuUpgradeTurretH")
	new cb = menu_makecallback("menuUpgradeTurretCb")
	
	new szData[4]
	num_to_str(turret, szData, 3)
	menu_additem(menu, szDamage,szData,_,cb)
	menu_additem(menu, szRange,_,_,cb)

	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu)

	return PLUGIN_CONTINUE
}
public menuUpgradeTurretCb(id, menu, item)
{
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if((item == 0 && gPlayerTurretDamageLevel[id][turret]+1 >= 5)
	|| (item == 0 && (gTurretsPriceData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)][gPlayerTurretDamageLevel[id][turret]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED
	if((item == 1 && gPlayerTurretRangeLevel[id][turret]+1 >= 5)
	|| (item == 1 && (gTurretsPriceData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)][gPlayerTurretRangeLevel[id][turret]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED
	
	return ITEM_ENABLED
}
/* komentarz */

public menuUpgradeTurretH(id, menu, item)
{	
	new cb, acces, szName[3], szDataItem[4]
	
	menu_item_getinfo(menu, 0, acces, szDataItem, 3, szName, 2, cb)
	
	new turret = str_to_num(szDataItem);
	
	if(item == MENU_EXIT || !is_user_alive(id))
	{
		DeleteTurretRanger(gPlayerTurretEnt[id][turret])
		if(is_user_alive(id))
			menuTurret(id, turret)
		return PLUGIN_CONTINUE
	}
	
	gPlayerTurretIsUpgrading[id][turret] = true;
	
	if(item == 0) {
		gPlayerTurretDamageLevel[id][turret]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)][gPlayerTurretDamageLevel[id][turret]])
		
	}
	if(item == 1) {
		gPlayerTurretRangeLevel[id][turret]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][turret], EV_INT_turret_type)][gPlayerTurretRangeLevel[id][turret]])
	}
	
	ColorChat(id, GREEN, "%s^x01 Trwa modernizacja wiezyczki...[^x04 %0.1f^x01 ]", gszPrefix, gCvarValue[TURRET_UPGRADE_TIME]);
	DeleteTurretRanger(gPlayerTurretEnt[id][turret])
	
	new szData[4]
	szData[0] = id
	szData[1] = item
	szData[2] = turret
	
	ChangeAmmoBar(gPlayerTurretEnt[id][turret], 5, 1)
	entity_set_float(gPlayerTurretEnt[id][turret], EV_FL_nextthink, 0.0)
	entity_set_float(gPlayerTurretEnt[id][turret], EV_FL_nextthink, get_gametime()+gCvarValue[TURRET_UPGRADE_TIME])
	
	set_task(gCvarValue[TURRET_UPGRADE_TIME], "menuUpgradeTurretPost",id +  gTasks[TASK_UPGRADE_TURRET], szData, 3)
	
	menuUpgradeTurretUpgrading(id)
	
	return PLUGIN_CONTINUE
}

public menuUpgradeTurretPost(szData[], iTask) {	
	new id = szData[0]
	new item = szData[1] // 0 - obra¿enia | 1 - zasiêg
	new sentry = szData[2]
	
	remove_task(iTask - id)
	
	gPlayerTurretIsUpgrading[id][sentry] = false;
	
	if(item == 0) {
		ColorChat(id, GREEN, "%s^x01 Twoja wiezyczka zadaje teraz od^x04 %d^x01 do^x04 %d^x01 obrazen!", gszPrefix, gTurretsDamageData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][sentry], EV_INT_turret_type)][gPlayerTurretDamageLevel[id][sentry]][0], gTurretsDamageData[e_TurretsType:entity_get_int(gPlayerTurretEnt[id][sentry], EV_INT_turret_type)][gPlayerTurretDamageLevel[id][sentry]][1])
	} else if(item == 1) {
		ColorChat(id, GREEN, "%s^x01 Twoja wiezyczka ma zasieg teraz^x04 %d jednostek!", gszPrefix, gTurretsRangeData[ e_TurretsType:entity_get_int(gPlayerTurretEnt[id][sentry], EV_INT_turret_type) ][ gPlayerTurretRangeLevel[id][sentry] ])		
	}
	
	new iPrevLvl = gPlayerTurretLevel[id][sentry]
	gPlayerTurretLevel[id][sentry] = floatround((gPlayerTurretDamageLevel[id][sentry] + gPlayerTurretRangeLevel[id][sentry] +1) / 2.0, floatround_ceil)

	if(iPrevLvl != gPlayerTurretLevel[id][sentry]) {
		ColorChat(id, GREEN, "%s^x01 Twoja wiezyczka ma teraz^x03 poziom %d!", gszPrefix, gPlayerTurretLevel[id][sentry])
	}

	new szModel[64];
	formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", gPlayerTurretLevel[id][sentry])
	
	entity_set_model(gPlayerTurretEnt[id][sentry], szModel)
	

	menuUpgradeTurret(id, sentry)
}

public menuUpgradeTurretUpgrading(id)
{
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
	
	new menu = menu_create("\wTrwa ulepszanie wiezyczki...", "menuUpgradeTurretUpgradingH");
	new iCb = menu_makecallback("menuUpgradeTurretUpgradingCb")
	
	menu_additem(menu, "W trakcie modernizacji ..",_,_, iCb)
	menu_additem(menu, "W trakcie modernizacji ..",_,_,iCb)
	
	menu_setprop(menu, MPROP_EXITNAME, "Pokaz menu wiezyczki po ulepszeniu")
	menu_display(id, menu)

	return PLUGIN_CONTINUE
}

public menuUpgradeTurretUpgradingCb(id, menu, item) {
	return ITEM_DISABLED
}

public menuUpgradeTurretUpgradingH(id, menu, item){
}


public CreateTurretRanger(turret)
{
	if(!is_valid_ent(turret))
		return PLUGIN_CONTINUE
	
	if(td_is_ranger_exists(turret))
		DeleteTurretRanger(turret)
		
	new Float:Origin[3], Float:Angles[3]
	
	new ranger = create_entity("env_sprite")
	
	entity_set_edict(turret, EV_ENT_turret_ranger, ranger)
	
	entity_set_string(ranger, EV_SZ_classname, "ranger")
	entity_set_model(ranger, gSpriteRanger)
	entity_set_edict(ranger, EV_ENT_turret_owner, entity_get_edict(turret, EV_ENT_turret_owner))
	
	/* K¹t */
	
	entity_get_vector(ranger, EV_VEC_angles, Angles)
	entity_get_vector(turret, EV_VEC_origin, Origin)
	
	Angles[0] += 90
	
	Origin[2] += 1.0
	
	
	entity_set_origin(ranger, Origin)
	entity_set_vector(ranger, EV_VEC_angles, Angles)
	
	new id = entity_get_edict(turret, EV_ENT_turret_owner)
	new sentryid = entity_get_int(turret, EV_INT_turret_id)
	new e_TurretsType:type = e_TurretsType:entity_get_int(turret, EV_INT_turret_type)
	new lvl = gPlayerTurretRangeLevel[id][sentryid]
	new range = gTurretsRangeData[type][lvl]
	
	entity_set_float(ranger, EV_FL_scale, range/250.0)
	fm_set_rendering(ranger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
	
	return PLUGIN_CONTINUE
}

public DeleteTurretRanger(turret) {
	if(!is_valid_ent(entity_get_edict(turret, EV_ENT_turret_ranger)))
		return PLUGIN_CONTINUE
	
	remove_entity(entity_get_edict(turret, EV_ENT_turret_ranger))
	entity_set_edict(turret, EV_ENT_turret_ranger, 0)
	
	return PLUGIN_CONTINUE
}	
public CreateTurret(id, sentryid, type) {
	
	gPlayerTurretMove[id] = 0
	new Float:fOrigin[3];
	get_origin_from_dist_player(id, 70.0, fOrigin)
	new entlist[3]
	if(find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin)) {
		client_print(id, print_center, "Nie mozesz stawiac wiezyczek zbyt blisko siebie!")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	if(find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin)) {
		client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}

	new iEnt = create_entity("info_target")

	entity_set_string(iEnt, EV_SZ_classname, "turret");
	entity_set_model(iEnt, "models/TD/sentrygun_1.mdl");
	
	entity_set_size(iEnt, Float:{-16.0, -16.0, 0.0}, Float:{16.0, 16.0, 48.0});
	entity_set_origin(iEnt, fOrigin);
	
	entity_set_int(iEnt, EV_INT_movetype, MOVETYPE_TOSS);
	entity_set_vector(iEnt, EV_VEC_angles, Float:{0.0, 0.0, 0.0});
	entity_set_byte(iEnt, EV_BYTE_controller2, 127);
	entity_set_float(iEnt, EV_FL_takedamage, DAMAGE_YES);
	entity_set_float(iEnt, EV_FL_health, 99999.9)
	
	entity_set_edict(iEnt, EV_ENT_turret_owner, id)
	entity_set_int(iEnt, EV_INT_turret_id, sentryid)
	entity_set_int(iEnt, EV_INT_turret_type, type)
	entity_set_int(iEnt, EV_INT_turret_firemode, 1)
	
	gPlayerTurretType[id][sentryid] = e_TurretsType:type
	gPlayerTurretEnt[id][sentryid] = iEnt
	gPlayerTurretLevel[id][sentryid] = 1
	gPlayerTurretDamageLevel[id][sentryid] = 0
	gPlayerTurretRangeLevel[id][sentryid] = 0
	gPlayerTurretAmmo[id][sentryid] = (e_TurretsType:type==TURRET_NORMAL?100:e_TurretsType:type==TURRET_LASER?51:e_TurretsType:type==TURRET_LIGHTING?150:0)
	gPlayerTurretNum[id]++
	gServerTurretsNum++
	
	drop_to_floor(iEnt)
	emit_sound(id, CHAN_AUTO, gSounds[SOUND_TURRET_PLANT], 1.0, ATTN_NORM, 0, PITCH_NORM);
	td_set_user_info(id, PLAYER_GOLD, _:td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:type][0])
	
	ColorChat(id, GREEN, "%s^x01 Trwa instalowanie wiezyczki...(^x04 %0.1f s.^x01 )", gszPrefix, gCvarValue[TURRET_INSTALL_TIME])
	
	set_task(gCvarValue[TURRET_INSTALL_TIME], "CreateTurretFinishInfo", id+gTasks[TASK_CREATE_TURRET_INFO])
	CreateAmmoBar(iEnt)
	
	entity_set_float(iEnt, EV_FL_nextthink, get_gametime() + gCvarValue[TURRET_INSTALL_TIME]);
	
	menuTurret(id, sentryid)
	return PLUGIN_CONTINUE
}
	
public CreateTurretFinishInfo(id){
	id-=gTasks[TASK_CREATE_TURRET_INFO]
	ColorChat(id, GREEN, "%s^x01 Twoja wiezyczka jest juz gotowa!", gszPrefix)
}

public TurretThink(ent) {
	if(!is_valid_ent(ent))
		return PLUGIN_CONTINUE
	
	new e_TurretsType:iType = e_TurretsType:entity_get_int(ent, EV_INT_turret_type)
	new iPlayer = entity_get_edict(ent, EV_ENT_turret_owner)
	new iSentry = entity_get_int(ent, EV_INT_turret_id)
	new iShoot = entity_get_int(ent, EV_INT_turret_firemode)
	new iTarget = entity_get_int(ent, EV_INT_turret_target)
	
	static Float:TurretOrigin[3]
	static Float:TargetOrigin[3]
	static ammo 
	ammo = gPlayerTurretAmmo[iPlayer][iSentry]
	
	/* Nie strzelaj */
	ChangeAmmoBar(ent, ammo, 0)
	
	if(ammo == 0) {
		emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NOAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		
		ColorChat(iPlayer, GREEN, "%s^x01 Jedna z twoich wiezyczek nie ma juz amunicji!", gszPrefix)
		client_cmd(iPlayer, "spk sound/%s", gSounds[SOUND_TURRET_NOAMMO]);
		
		gPlayerTurretAmmo[iPlayer][iSentry]--
		return PLUGIN_CONTINUE
	}
	
	/* ============ */
	
	if(iShoot && is_valid_ent(iTarget)) 
	{
		if(!fm_is_ent_visible(ent, iTarget) || entity_get_int(iTarget, EV_INT_iuser1) == 0) 
		{
			fireoff:
			iShoot = 0
			entity_set_int(ent, EV_INT_turret_firemode, 0)
			entity_set_int(ent, EV_INT_turret_target, 0)
			emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_STOP_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
			
			entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.1);
			return PLUGIN_CONTINUE
		}
		
		entity_get_vector(iTarget, EV_VEC_origin, TargetOrigin)
		entity_get_vector(ent, EV_VEC_origin, TurretOrigin)
		
		if(get_distance_f(TargetOrigin, TurretOrigin) > gTurretsRangeData[iType][gPlayerTurretRangeLevel[iPlayer][iSentry]])
			goto fireoff;
		
			
		TurretTurnToTarget(ent, iTarget);
		
		TurretOrigin[2] += 45.0
		
		gPlayerTurretAmmo[iPlayer][iSentry]--
		
		if(ammo-1 == giPlayerAlarmValue[iPlayer])
		{
			ColorChat(iPlayer, GREEN, "%s^x01 Jednej z twoich wiezyczek konczy sie amunicja!", gszPrefix)
			gPlayerAlarmStatus[iPlayer][iSentry] = true;
			
			client_cmd(iPlayer, "spk sound/%s", gSounds[SOUND_TURRET_LOWAMMO]);
			emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LOWAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		}
		
		switch(iType) {
			case TURRET_NORMAL: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NORMAL_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NORMAL_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LASER: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LASER_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LASER_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LIGHTING: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LIGHTING_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LIGHTING_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
		}
		switch(iType) {
			case TURRET_NORMAL: {
				message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
				write_byte(TE_TRACER);
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				message_end();
				
				createShell(ent, TurretOrigin, 1)
			}
			case TURRET_LASER: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(gSpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(5*(gPlayerTurretLevel[iPlayer][iSentry])) // gruboœæ
				write_byte(1)
				switch(gPlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5)
				message_end()
			}
			case TURRET_LIGHTING: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(gSpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(10) // gruboœæ
				write_byte(16)
				switch(gPlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5) //szybkoœæ
				message_end()
			}	
		}
		
		/* Zadawanie obrazen */
		switch(random_num(1, 4)) 
		{
			case 1, 2, 3: {
				new Float:dmg
				dmg = random_float(float(gTurretsDamageData[iType][gPlayerTurretDamageLevel[iPlayer][iSentry]][0]),float(gTurretsDamageData[iType][gPlayerTurretDamageLevel[iPlayer][iSentry]][1]))
				ExecuteHamB(Ham_TakeDamage, iTarget, iPlayer, iPlayer, dmg, DMG_DROWN, 1);
			}
			case 4: {
				// jeœli wie¿yczka nietrafi³a
			}
		}
		
		/* Thinki */
		
		switch(iType) {
			case TURRET_NORMAL: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_NORMAL]/100.0));
			case TURRET_LASER: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_LASER]/100.0));
			case TURRET_LIGHTING: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_LIGHTING]/100.0));
		}
		
		return PLUGIN_CONTINUE	
	}
	else
		iShoot = 0
		
	iTarget = TurretGetClosestMonster(ent)

	if(iTarget && (iTarget && fm_is_ent_visible(ent, iTarget)))
	{
		emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_START_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
		TurretTurnToTarget(ent, iTarget);
		
		entity_set_int(ent, EV_INT_turret_target, iTarget)
		entity_set_int(ent, EV_INT_turret_firemode, 1)
		
		entity_set_float(ent, EV_FL_nextthink, get_gametime() + gCvarValue[TURRET_CHANGE_ENEMY_TIME]);
		return PLUGIN_CONTINUE
	}
	

	
	/*  Stan Wolny  */
	if(!iShoot) {
		
		new controler1 = entity_get_byte(ent, EV_BYTE_controller1)+2;
		if(controler1 > 255)
			controler1 = 0;
		entity_set_byte(ent, EV_BYTE_controller1, controler1);
			
		new controler2 = entity_get_byte(ent, EV_BYTE_controller2);
		if(controler2 > 127 || controler2 < 127)
			entity_set_byte(ent, EV_BYTE_controller2, 127);
		

		entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.25);
	}
	return PLUGIN_CONTINUE
}

stock TurretTurnToTarget(ent, enemy, mode = 0, Float:enemyOrigin[3] = {0.0, 0.0, 0.0})
{
	static Float:sentryOrigin[3], Float:closestOrigin[3]
	entity_get_vector(ent, EV_VEC_origin, sentryOrigin)
	
	if(enemyOrigin[0] == 0.0 && enemyOrigin[1] == 0.0 && enemyOrigin[2] == 0.0)
		entity_get_vector(enemy, EV_VEC_origin, closestOrigin)
	else
		closestOrigin = enemyOrigin
		
	new newTrip, Float:newAngle = floatatan(((closestOrigin[1]-sentryOrigin[1])/(closestOrigin[0]-sentryOrigin[0])), radian) * 57.2957795;

	if(closestOrigin[0] < sentryOrigin[0])
		newAngle += 180.0;
	if(newAngle < 0.0)
		newAngle += 360.0;
	
	sentryOrigin[2] += 35.0
	if(closestOrigin[2] > sentryOrigin[2])
		newTrip = 0;
	if(closestOrigin[2] < sentryOrigin[2])
		newTrip = 255;
	if(closestOrigin[2] == sentryOrigin[2])
		newTrip = 127;
		
	entity_set_byte(ent, EV_BYTE_controller1, floatround(newAngle*0.70833));
	entity_set_byte(ent, EV_BYTE_controller2, newTrip);
	
	if(!mode)
	{
		entity_set_byte(ent, EV_BYTE_controller3, entity_get_byte(ent, EV_BYTE_controller3)+20>255? 0: entity_get_byte(ent, EV_BYTE_controller3)+20);
	}
}

public TurretGetClosestMonster(ent) {
	new Float:flDistanse = float( gTurretsRangeData[e_TurretsType:entity_get_int(ent, EV_INT_turret_type)][gPlayerTurretRangeLevel[entity_get_edict(ent, EV_ENT_turret_owner)][entity_get_int(ent, EV_INT_turret_id)]])
	new Float:fOrigin1[3];
	new Float:fOrigin2[3]
	
	entity_get_vector(ent, EV_VEC_origin, fOrigin1)
	
	new tempEntID;
	new entlist[6]
	new Float:dis;
	for(new i ; i < find_sphere_class(ent, "monster", flDistanse, entlist, 5) ; i++) 
	{	if(entity_get_int(entlist[i], EV_INT_iuser1) == 0)
			continue

		entity_get_vector(entlist[i], EV_VEC_origin, fOrigin2);
		
		dis = get_distance_f(fOrigin1, fOrigin2)
		if(dis < flDistanse)
		{
			flDistanse = dis;
			tempEntID = entlist[i];
		}	
	}
	return tempEntID;
}

public LoadSound() {
	new szText[128], len;
	new szTemp[3][128];

	if(!file_exists(gszSoundConfigFile))
	{
		log_to_file(gszLogFile, "Brak pliku konfiguracyjnego dzwiekow...")
		return PLUGIN_CONTINUE
	}
	
	for(new i ; read_file(gszSoundConfigFile, i, szText, 127, len) ; i++)
	{
		if(equali(szText, ";") || equali(szText, ""))
			continue;
			
		parse(szText, szTemp[0], 127, szTemp[1], 16, szTemp[2], 127)
		remove_quotes(szTemp[2]);
		
		if(equali(szTemp[0], "TURRET_NORMAL_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_NORMAL_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NORMAL_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_NORMAL_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_LASER_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_LASER_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_LIGHTING_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_LIGHTING_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_START_FIRE")) 
			copy(gSounds[SOUND_TURRET_START_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_STOP_FIRE")) 
			copy(gSounds[SOUND_TURRET_STOP_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_PLANT")) 
			copy(gSounds[SOUND_TURRET_PLANT], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LOW_AMMO")) 
			copy(gSounds[SOUND_TURRET_LOWAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NO_AMMO")) 
			copy(gSounds[SOUND_TURRET_NOAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "MENU_SELECT")) 
			copy(gSounds[SOUND_MENU_SELECT], 127, szTemp[2])
	}

	return PLUGIN_CONTINUE
}

public LoadTurretsConfig()
{
	new szText[64], len
	new szData[64], iData[2][6]
	new szFormat[64]
	
	server_cmd("exec addons/amxmodx/configs/td_cvars.cfg");
	
	if(!file_exists(gszTurretsConfigFile))
	{
		log_to_file("Tower Defense.log", "TURRETS : Brak pliku konfiguracyjnego '%s'. Gra niemozliwa. ", gszTurretsConfigFile)
		td_set_game_status(eGame:GAME_NOT_AVAILABLE)
		return PLUGIN_CONTINUE
	}
	
	for(new i = 0 ; read_file(gszTurretsConfigFile, i, szText, 63, len); i ++)
	{
		if(szText[0] == ';' || (szText[0] == '/' && szText[1] == '/') || equali(szText, ""))
			continue;
		
		replace_all(szText, 63, "=", "")
		
		parse(szText, szData, 63, iData[0], 5, iData[1], 5)
		
		new iNum = str_to_num(iData[0])
		new iNum2 = str_to_num(iData[1])
		
		if(equali(szData, "NORMAL_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_NORMAL] = iNum
			continue
		}
		
		for(new x = 1 ; x <= 5; x++)
		{
			formatex(szFormat, 63, "NORMAL_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_NORMAL][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "NORMAL_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_NORMAL][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "NORMAL_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_NORMAL][x-1][0] = iNum
				gTurretsDamageData[TURRET_NORMAL][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		if(equali(szData, "LASER_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_LASER] = iNum
			continue
		}
		
		for(new x = 1; x <= 5; x++)
		{
			formatex(szFormat, 63, "LASER_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_LASER][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LASER_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_LASER][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LASER_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_LASER][x-1][0] = iNum
				gTurretsDamageData[TURRET_LASER][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		if(equali(szData, "LIGHTING_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_LIGHTING] = iNum
			continue
		}
		
		for(new x = 1; x <= 5; x++)
		{
			formatex(szFormat, 63, "LIGHTING_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_LIGHTING][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LIGHTING_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_LIGHTING][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LIGHTING_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_LIGHTING][x-1][0] = iNum
				gTurretsDamageData[TURRET_LIGHTING][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		
	}
	MAX_MAP_TURRET = clamp(td_get_max_map_turrets(), 1, MAX_SERVER_TURRET)
	return PLUGIN_CONTINUE;
}

stock createShell(index, Float:fOrigin[3], num)
{
	for(new i; i < num;i++)
	{
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY, {0.0, 0.0, 0.0}, index);
		write_byte(TE_MODEL);
		write_coord(floatround(fOrigin[0]));
		write_coord(floatround(fOrigin[1]));
		write_coord(floatround(fOrigin[2]));
		write_coord(random_num(-100,100));
		write_coord(random_num(-100,100));
		write_coord(random_num(100,200));
		write_angle(random_num(0,360));
		write_short(gShellIndex);
		write_byte(0);
		write_byte(100);
		message_end()
	}
}

stock get_origin_from_dist_player(id, Float:dist, Float:origin[3], s3d = 1) {
	new Float:idorigin[3];
	entity_get_vector(id, EV_VEC_origin, idorigin); // lub pev(id, pev_origin, idorigin) dla fakemety
	
	if(dist == 0) {
		origin = idorigin;
		return;
	}
	
	new Float:idvangle[3];
	entity_get_vector(id, EV_VEC_v_angle, idvangle); // lub pev(id, pev_v_angle, idvangle) dla fakemety
	idvangle[0] *= -1;
	origin[0] = idorigin[0] + dist * floatcos(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[1] = idorigin[1] + dist * floatsin(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[2] = idorigin[2]
}

public ChangeAlarmValue(id, iValue) {
	giPlayerAlarmValue[id] = iValue
	
	for(new i ; i < MAX_PLAYER_TURRET ; i++) {	
		if(gPlayerTurretAmmo[id][i] > iValue){
			gPlayerAlarmStatus[id][i] = false
		}
	}
}

public CreateAmmoBar(Turret)
{
	if(!td_is_turret(Turret) || gCvarValue[TURRET_SHOW_AMMO_BAR]== 0)
		return
		
	new Float:Origin[3]
	entity_get_vector(Turret, EV_VEC_origin, Origin)
	
	new sprite = create_entity("env_sprite")
	
	entity_set_edict(Turret, EV_ENT_turret_ammobar, sprite)
	entity_set_string(sprite, EV_SZ_classname, "ammobar")
	entity_set_model(sprite, gSpriteAmmoBar)
	entity_set_edict(sprite, EV_ENT_turret_owner, entity_get_edict(Turret, EV_ENT_turret_owner))
	Origin[2]+=63
	
	entity_set_origin(sprite, Origin)
	entity_set_float(sprite, EV_FL_scale, 0.3)
}

public ChangeAmmoBarScale(id, Float:fScale) {
	gfPlayerAmmoBarScale[id] = fScale;	
}

public ChangeAmmoBar(turret, ammo, upgrading )
{
	if(gCvarValue[TURRET_SHOW_AMMO_BAR] == 0)
	{
		RemoveAmmoBar(turret)
		return;
	}
	new ammobar = entity_get_edict(turret, EV_ENT_turret_ammobar)
	if(!is_valid_ent(ammobar))
		CreateAmmoBar(turret)

	if(!td_is_ammobar(ammobar))
		return ;

	static R,G,B
	if(ammo >= 500)
	{
		R = 0
		G = 255
		B = 0
	}
	else if(ammo < 500 && ammo >= 450)
	{
		R = 34
		G = 255
		B = 0
	}
	else if(ammo < 450 && ammo >= 400)
	{
		R = 70
		G = 255
		B = 0
	}
	else if(ammo < 400 && ammo >= 350)
	{
		R = 120
		G = 255
		B = 0
	}
	else if(ammo < 350 && ammo >= 300)
	{
		R = 170
		G = 255
		B = 0
	}
	else if(ammo < 300 && ammo >= 250)
	{
		R = 210
		G = 255
		B = 0
	}
	else if(ammo < 250 && ammo >= 200)
	{
		R = 255
		G = 255
		B = 0
	}
	else if(ammo < 200 && ammo >= 150)
	{
		R = 238
		G = 200
		B = 0
	}
	else if(ammo < 150 && ammo >= 125)
	{
		R = 255
		G = 150
		B = 0
	}
	else if(ammo < 125 && ammo >= 100)
	{
		R = 255
		G = 125
		B = 0
	}
	else if(ammo < 100 && ammo >= 75)
	{
		R = 255
		G = 100
		B = 0
	}
	else if(ammo < 75 && ammo >= 50)
	{
		R = 255
		G = 75
		B = 0
	}
	else if(ammo < 50 && ammo >= 25)
	{
		R = 255
		G = 50
		B = 0
	}
	else if(ammo < 25 && ammo >= 10)
	{
		R = 255
		G = 25
		B = 0
	}
	else if(ammo < 10 && ammo >= -1)
	{
		R = 255
		G = 0
		B = 0
	}
	else if(ammo < -1)
	{
		R = 0
		G = 0
		B = 255
	}
	if(upgrading)
	{
		R = 4
		B = 134
		G = 8
	}
	if(is_valid_ent(ammobar))
	{

		fm_set_rendering(ammobar, kRenderFxNone, R, G, B, kRenderTransAdd, 255)
	}
}

public RemoveAmmoBar(turret) {
	if(is_valid_ent(entity_get_edict(turret, EV_ENT_turret_ammobar))) {

		entity_set_edict(entity_get_edict(turret, EV_ENT_turret_ammobar), EV_ENT_turret_owner, 0)
		remove_entity(entity_get_edict(turret, EV_ENT_turret_ammobar))
	}
}
public td_is_turret(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[10]
	entity_get_string(iEnt, EV_SZ_classname, classname, 9)
	if(equali(classname, "turret"))
		return 1;
	return 0;
}


public td_is_ranger(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[8]
	entity_get_string(iEnt, EV_SZ_classname, classname, 7)
	if(equali(classname, "ranger"))
		return 1;
	return 0;
}

public td_is_ammobar(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[11]
	entity_get_string(iEnt, EV_SZ_classname, classname, 10)
	if(equali(classname, "ammobar"))
	{
		return 1;
	}
	return 0;
}

public td_is_turret_on_server() {
	return gServerTurretsNum ? 1 : 0
}
public td_is_ranger_exists(iEnt) {	
	if(is_valid_ent(entity_get_edict(iEnt, EV_ENT_turret_ranger)))
		return 1;
	return 0;
}
	
